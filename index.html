100% { background-color: rgba(255,0,0,.0); }
}
.warning { animation: secretSauceWarning 1s infinite; position:fixed; inset:0; pointer-events:none; z-index:11; }
  
  /* Eating animation */
  @keyframes eatingPulse {
    0% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.2); opacity: 0.7; }
    100% { transform: scale(0.1); opacity: 0; }
  }
  .eating { animation: eatingPulse 1s forwards; }
  
  /* Player cat images */
  .cat-img {
    position: absolute;
    transform: translate(-50%, -50%);
    width: 50px;
    height: 50px;
    object-fit: cover;
    border-radius: 50%;
  }
</style>
</head>
<body>
@@ -54,56 +72,67 @@
</div>
<div id="center" class="ctr">
<div style="font-size:42px; font-weight:900; margin-bottom:10px;">Meow Mayhem üòº</div>
    <div style="font-size:18px; opacity:.9; margin-bottom:20px;">Collect üêü. Bonk friends. Avoid chaos. First to <span id="targetPts">10</span> wins.</div>
    <div style="font-size:18px; opacity:.9; margin-bottom:20px;">Collect üêü. Bonk friends. Avoid chaos. First to <span id="targetPts">30</span> wins.</div>
<div class="btn" id="startBtn">Press ENTER or Click to Start</div>
<div class="hint">P1: WASD + F ‚Ä¢ P2: Arrows + / ‚Ä¢ (Enable up to 5 players in code)</div>
</div>
<div id="powerups" class="powerups"></div>
  <div id="timer" class="timer" style="display:none;">Time: 00:00</div>
  <div id="timer" class="timer">Chaos in: 30s</div>
<div class="bottom">Pause: <b>P</b> ‚Ä¢ Restart: <b>R</b></div>
</div>
<div id="nightMode" class="night-mode" style="display:none;"></div>
<div id="warning" class="warning" style="display:none;"></div>

<!-- Cat images container (will be dynamically populated) -->
<div id="catImagesContainer" style="position:absolute; top:0; left:0; pointer-events:none;"></div>

<script>
(() => {
// ======== CONFIG ========
const CONFIG = {
    targetScore: 10,
    targetScore: 30, // Increased from 10 to 30
maxPlayers: 2, // Change to 3, 4, or 5 if you want more local players
    playerRadius: 22,
    playerRadius: 25,
playerSpeed: 2.4,
friction: 0.86,
meowCooldownMs: 1100,
meowKnockRange: 140, // Increased from 95
meowKnockForce: 9.5, // Increased from 5.5
    meowParticles: 12, // New: particles count
    meowParticles: 12, // Particles count
treatRadius: 10,
treatsOnField: 6,
treatRespawnMs: 1600,
dogeEveryMs: 9000,
dogeSpeed: 2.0, // Speed for doge to chase player (slightly slower than player)
    dogeEatTimeMs: 1000, // How long the eating animation takes
roombas: 2,
    laserCount: 5, // Increased from 1 to 5
    laserCount: 5,
laserActive: true,
laserInvertMs: 2000,
boundsPadding: 8,
powerUpChance: 0.004, // Chance per frame to spawn a power-up
weatherEvents: true, // Enable/disable weather events
    weatherDuration: 10000, // Weather event duration in ms
    weatherCooldown: 30000, // Time between weather events
    gameTime: 180, // Game time in seconds (3 minutes)
    timeLimit: true, // Enable time limit
    secretSauce: true, // Enable secret sauce mode
    secretSauceInterval: 45000, // Interval between secret sauce events
    weatherDuration: 8000, // Weather event duration in ms (8 seconds)
    weatherCooldown: 5000, // Time between weather events (reduced to 5 seconds)
    secretSauceInterval: 30000, // Chaos mode every 30 seconds
    secretSauceDuration: 8000, // How long chaos mode lasts (8 seconds)
};

  // Cat GIFs for the players
  const CAT_GIFS = [
    "https://media.tenor.com/SuVGs-GL7RoAAAAi/shocked-shocked-cat.gif", // Grumpy
    "https://media.tenor.com/Ym6VeAcZoTcAAAAi/aaaah-cat.gif",          // Nyan
    "https://media.tenor.com/1Z8PTLFT8HUAAAAi/voices-cat.gif",         // Keyboard
    "https://media.tenor.com/T_avUEk3aWwAAAAi/catgroove7tv-catgroove.gif", // Bongo
    "https://media.tenor.com/y-Ew-QGLcpYAAAAi/shrek-cat.gif",          // Shrek Cat
  ];

const SKINS = [
    { name:"Grumpy", emoji:"üòæ", chip:"p1", color:"#ff9aa2", image: "üê±" },
    { name:"Nyan", emoji:"üåà", chip:"p2", color:"#9ad1ff", image: "üê±" }, 
    { name:"Keyboard", emoji:"üéπ", chip:"p3", color:"#b5ff9a", image: "üê±" },
    { name:"Bongo", emoji:"ü•Å", chip:"p4", color:"#ffdf9a", image: "üê±" },
    { name:"Shrek", emoji:"üëπ", chip:"p5", color:"#c4a2ff", image: "üê±" }, // Added Shrek Cat
    { name:"Grumpy", emoji:"üòæ", chip:"p1", color:"#ff9aa2", gifIndex: 0 },
    { name:"Nyan", emoji:"üåà", chip:"p2", color:"#9ad1ff", gifIndex: 1 }, 
    { name:"Keyboard", emoji:"üéπ", chip:"p3", color:"#b5ff9a", gifIndex: 2 },
    { name:"Bongo", emoji:"ü•Å", chip:"p4", color:"#ffdf9a", gifIndex: 3 },
    { name:"Shrek", emoji:"üëπ", chip:"p5", color:"#c4a2ff", gifIndex: 4 },
];

// Power-up types
@@ -118,7 +147,11 @@
}},
{ name: "Giant Mode", emoji: "ü¶ñ", color: "#ff00ff", duration: 7000, effect: (player) => {
player.r *= 1.6;
      return () => player.r = CONFIG.playerRadius;
      updateCatImageSize(player);
      return () => {
        player.r = CONFIG.playerRadius;
        updateCatImageSize(player);
      };
}},
{ name: "Super Meow", emoji: "üîä", color: "#ff6600", duration: 8000, effect: (player) => {
player.superMeow = true;
@@ -156,14 +189,6 @@
updateStatus("");
}
},
    { name: "Treat Rain", onStart: () => {
        treatRain = true;
        updateStatus("üêü It's raining treats!");
      }, onEnd: () => {
        treatRain = false;
        updateStatus("");
      }
    },
{ name: "Super Speed", onStart: () => {
CONFIG.playerSpeed *= 1.5;
updateStatus("üí® Everyone moves super fast!");
@@ -177,6 +202,7 @@
// ======== SETUP ========
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
  const catImagesContainer = document.getElementById('catImagesContainer');
let W = 0, H = 0;
const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
function resize() {
@@ -187,6 +213,8 @@
canvas.style.width = W + 'px';
canvas.style.height = H + 'px';
ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    catImagesContainer.style.width = W + 'px';
    catImagesContainer.style.height = H + 'px';
}
resize();
window.addEventListener('resize', resize);
@@ -207,29 +235,22 @@
if (entity.y < r) { entity.y = r; entity.vy = Math.abs(entity.vy)*0.6; }
if (entity.y > H - r) { entity.y = H - r; entity.vy = -Math.abs(entity.vy)*0.6; }
}
  
  // Format time as MM:SS
  function formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  }

// ======== ENTITIES ========
const players = [];
const treats = [];
const roombas = [];
const meowBursts = [];
  const meowParticles = []; // New: particles array
  const powerUps = []; // New: power-ups array
  const meowParticles = []; // Particles array
  const powerUps = []; // Power-ups array
let doge = null;
  const lasers = []; // Changed from single laser to array of lasers
  const lasers = []; // Array of lasers
let tornado = null;
  let treatRain = false;
let currentWeather = null;
let nextWeatherEvent = 0;
let nextSecretSauce = 0;
let secretSauceActive = false;
  let secretSauceCountdown = 30;

// Player controls map
const CONTROL_SETS = [
@@ -240,7 +261,58 @@
{ up:'8', down:'5', left:'4', right:'6', meow:'0' },
];

  // Create cat image element for a player
  function createCatImage(player) {
    const img = document.createElement('img');
    img.className = 'cat-img';
    img.src = CAT_GIFS[player.skin.gifIndex];
    img.id = `cat-${player.id}`;
    img.style.width = `${player.r * 2}px`;
    img.style.height = `${player.r * 2}px`;
    catImagesContainer.appendChild(img);
    return img;
  }
  
  // Update cat image size (for power-ups, etc.)
  function updateCatImageSize(player) {
    if (player.imgElement) {
      player.imgElement.style.width = `${player.r * 2}px`;
      player.imgElement.style.height = `${player.r * 2}px`;
    }
  }
  
  // Update cat image position
  function updateCatImagePositions() {
    players.forEach(p => {
      if (p.imgElement) {
        p.imgElement.style.left = `${p.x}px`;
        p.imgElement.style.top = `${p.y}px`;
        
        // Apply eating animation class if being eaten
        if (p.beingEaten) {
          p.imgElement.classList.add('eating');
        } else {
          p.imgElement.classList.remove('eating');
        }
        
        // Apply shield visual effect
        if (p.hasShield) {
          p.imgElement.style.boxShadow = '0 0 10px 5px rgba(0, 255, 255, 0.7)';
        } else if (p.isBeingMeowed) {
          p.imgElement.style.boxShadow = '0 0 8px 4px rgba(255, 255, 255, 0.6)';
        } else {
          p.imgElement.style.boxShadow = 'none';
        }
      }
    });
  }

function spawnPlayers(n=CONFIG.maxPlayers){
    // First clean up any existing player images
    while (catImagesContainer.firstChild) {
      catImagesContainer.removeChild(catImagesContainer.firstChild);
    }
    
players.length = 0;
for(let i=0;i<n;i++){
const skin = SKINS[i % SKINS.length];
@@ -250,7 +322,7 @@
emoji: skin.emoji,
color: skin.color,
chip: skin.chip,
        image: skin.image,
        skin: skin,
x: W*(0.2 + 0.2*i),
y: H*(0.3 + 0.1*i),
vx:0, vy:0,
@@ -267,7 +339,14 @@
superMeow: false, // Power-up: super meow power
treatMagnet: false, // Power-up: attracts treats
activePowerUps: [], // Track active power-ups
        beingEaten: false, // Track if player is being eaten by doge
        eatenUntil: 0, // When player will respawn
        respawnPoint: { x: 0, y: 0 } // Where player will respawn
};
      
      // Create cat image element
      p.imgElement = createCatImage(p);
      
players.push(p);
}
updateScoreUI();
@@ -284,19 +363,6 @@
};
treats.push(t);
}
  
  // Special treats for treat rain
  function spawnRainTreat() {
    const t = { 
      x: rnd(CONFIG.boundsPadding, W-CONFIG.boundsPadding),
      y: -20,  // Spawn above the screen
      r: CONFIG.treatRadius, 
      emoji:'üêü',
      vx: rnd(-0.5, 0.5),
      vy: rnd(1, 3)
    };
    treats.push(t);
  }

function ensureTreats(){
while (treats.length < CONFIG.treatsOnField) spawnTreat();
@@ -325,8 +391,10 @@
vx: side==='L' ? rnd(2.0,2.5) : rnd(-2.5,-2.0),
vy: 0,
emoji:'üê∂', // Doge cameo
      ttl: 12000, // Increased lifespan so it can chase players longer
      target: null
      ttl: 15000, // Increased lifespan so it can chase players longer
      target: null,
      eating: null, // Which player is being eaten
      eatingStartTime: 0 // When eating started
};
}

@@ -422,6 +490,24 @@
});
}
}
  
  // Respawn a player after being eaten
  function respawnPlayer(player) {
    player.beingEaten = false;
    player.x = player.respawnPoint.x;
    player.y = player.respawnPoint.y;
    player.vx = 0;
    player.vy = 0;
    player.alive = true;
    
    // Remove eating animation from image
    if (player.imgElement) {
      player.imgElement.classList.remove('eating');
    }
    
    // Create respawn particle effect
    createExplosion(player.x, player.y, player.color, 20);
  }

// ======== GAME LOOP ========
let running = false;
@@ -430,17 +516,14 @@
const dt = 1000/60;
let nextTreatAt = 0;
let nextDogeAt = 0;
  let gameStartTime = 0;
  let gameTimeLeft = CONFIG.gameTime;

function start(){
if (running) return;
document.getElementById('center').style.display='none';
    document.getElementById('timer').style.display = CONFIG.timeLimit ? 'block' : 'none';
    document.getElementById('timer').style.display = 'block';
running = true;
resetGame();
last = performance.now();
    gameStartTime = last;
requestAnimationFrame(loop);
}

@@ -453,23 +536,23 @@
powerUps.length=0; // Clear power-ups
doge = null;
tornado = null;
    treatRain = false;
currentWeather = null;
if (CONFIG.laserActive) spawnLasers();
spawnRoombas();
for(let i=0;i<CONFIG.treatsOnField;i++) spawnTreat();
nextTreatAt = performance.now() + CONFIG.treatRespawnMs;
nextDogeAt = performance.now() + CONFIG.dogeEveryMs;
    nextWeatherEvent = performance.now() + 15000; // First weather after 15 seconds
    nextWeatherEvent = performance.now() + 5000; // First weather after 5 seconds
nextSecretSauce = performance.now() + CONFIG.secretSauceInterval;
secretSauceActive = false;
    secretSauceCountdown = 30;
document.getElementById('warning').style.display = 'none';
document.getElementById('nightMode').style.display = 'none';
    gameTimeLeft = CONFIG.gameTime;
winner = null;
paused = false;
updateStatus('Collect fish. First to ' + CONFIG.targetScore + '!');
document.getElementById('powerups').innerHTML = '';
    updateChaosTimer();
}

function updateStatus(s){ document.getElementById('status').textContent = s; }
@@ -510,6 +593,10 @@
});
});
}
  
  function updateChaosTimer() {
    document.getElementById('timer').textContent = `Chaos in: ${secretSauceCountdown}s`;
  }

let paused = false;
window.addEventListener('keydown', (e)=>{
@@ -521,6 +608,9 @@
let winner = null;

function handleInput(p){
    // Skip input handling if player is being eaten
    if (p.beingEaten) return;
    
const now = performance.now();
let up = keys.has(p.controls.up) || keys.has(p.controls.up.toUpperCase());
let down = keys.has(p.controls.down) || keys.has(p.controls.down.toUpperCase());
@@ -561,6 +651,7 @@
for (const other of players){
if (other === p) continue;
if (other.hasShield) continue; // Shield blocks meow
        if (other.beingEaten) continue; // Can't meow a player being eaten

const dx = other.x - p.x, dy = other.y - p.y;
const d = Math.hypot(dx,dy);
@@ -613,6 +704,14 @@
function updatePlayer(p){
const now = performance.now();

    // Handle respawning if eaten
    if (p.beingEaten && now > p.eatenUntil) {
      respawnPlayer(p);
    }
    
    // Skip other updates if being eaten
    if (p.beingEaten) return;
    
// Update meow effect status
if (p.isBeingMeowed && now > p.meowEffectUntil) {
p.isBeingMeowed = false;
@@ -681,6 +780,9 @@
for (let i=treats.length-1;i>=0;i--){
const t = treats[i];
for (const p of players){
        // Skip players being eaten
        if (p.beingEaten) continue;
        
if (circleCollide(p.x,p.y,p.r, t.x,t.y,t.r)){
p.score++;
updateScoreUI();
@@ -703,11 +805,6 @@
nextTreatAt = now + CONFIG.treatRespawnMs;
if (treats.length < CONFIG.treatsOnField) spawnTreat();
}
    
    // Treat rain
    if (treatRain && Math.random() < 0.1) {
      spawnRainTreat();
    }
}

function endGameWithWinner(p) {
@@ -723,6 +820,9 @@
if (r.y < 70 || r.y > H-40) r.vy *= -1;
// Push players slightly
for (const p of players){
        // Skip players being eaten
        if (p.beingEaten) continue;
        
if (circleCollide(p.x,p.y,p.r, r.x,r.y,r.r)){
const dx = p.x - r.x, dy = p.y - r.y; const d = Math.hypot(dx,dy)||1;
const nx = dx/d, ny = dy/d;
@@ -741,69 +841,103 @@
const now = performance.now();
if (!doge && now >= nextDogeAt){ nextDogeAt = now + CONFIG.dogeEveryMs; spawnDoge(); }
if (doge){
      // Find closest player to chase
      let closestDist = Infinity;
      let closestPlayer = null;
      for (const p of players) {
        const d = dist(doge, p);
        if (d < closestDist) {
          closestDist = d;
          closestPlayer = p;
        }
      }
      
      // Chase closest player
      if (closestPlayer) {
        const dx = closestPlayer.x - doge.x;
        const dy = closestPlayer.y - doge.y;
        const d = Math.hypot(dx, dy) || 1;
        doge.vx = (dx/d) * CONFIG.dogeSpeed;
        doge.vy = (dy/d) * CONFIG.dogeSpeed;
      // If doge is eating a player
      if (doge.eating) {
        const eatingDuration = now - doge.eatingStartTime;

        // In secret sauce mode, doge moves faster
        if (secretSauceActive) {
          doge.vx *= 1.5;
          doge.vy *= 1.5;
        // When done eating, release player (they will respawn)
        if (eatingDuration >= CONFIG.dogeEatTimeMs) {
          doge.eating = null;
}
      }
      
      doge.x += doge.vx; doge.y += doge.vy;
      doge.ttl -= 16;
      
      // Push players hard
      for (const p of players){
        if (circleCollide(p.x,p.y,p.r, doge.x,doge.y,doge.r)){
          const dx = p.x - doge.x, dy = p.y - doge.y; const d = Math.hypot(dx,dy)||1;
          const nx = dx/d, ny = dy/d;
          p.vx += nx*4.2; p.vy += ny*4.2;
      } 
      // If doge is not currently eating anyone, find a player to chase
      else {
        // Find closest player to chase
        let closestDist = Infinity;
        let closestPlayer = null;
        for (const p of players) {
          // Skip players already being eaten
          if (p.beingEaten) continue;
          
          const d = dist(doge, p);
          if (d < closestDist) {
            closestDist = d;
            closestPlayer = p;
          }
        }
        
        // Chase closest player
        if (closestPlayer) {
          const dx = closestPlayer.x - doge.x;
          const dy = closestPlayer.y - doge.y;
          const d = Math.hypot(dx, dy) || 1;
          doge.vx = (dx/d) * CONFIG.dogeSpeed;
          doge.vy = (dy/d) * CONFIG.dogeSpeed;

          // Particle effect when hit by doge
          createMeowParticles(p.x - (nx*p.r/2), p.y - (ny*p.r/2), "#ffbb33");
          // In secret sauce mode, doge moves faster
          if (secretSauceActive) {
            doge.vx *= 1.5;
            doge.vy *= 1.5;
          }

          // Secret sauce: chance to drop treats when hit by doge
          if (secretSauceActive && Math.random() < 0.3) {
            if (p.score > 0) {
              p.score--;
              updateScoreUI();
          // Check if doge catches a player to eat them
          for (const p of players) {
            // Skip players already being eaten
            if (p.beingEaten) continue;
            
            if (circleCollide(p.x, p.y, p.r, doge.x, doge.y, doge.r)) {
              // Start eating player
              doge.eating = p;
              doge.eatingStartTime = now;
              
              // Mark player as being eaten
              p.beingEaten = true;
              p.eatenUntil = now + CONFIG.dogeEatTimeMs;

              // Spawn a treat
              const t = { 
                x: p.x + rnd(-30, 30),
                y: p.y + rnd(-30, 30),
                r: CONFIG.treatRadius, 
                emoji:'üêü',
                vx: rnd(-2, 2),
                vy: rnd(-2, 2)
              // Set respawn point (random position)
              p.respawnPoint = {
                x: rnd(100, W-100),
                y: rnd(100, H-100)
};
              treats.push(t);

              createExplosion(p.x, p.y, "#ff6600", 15);
              // Eating effect particles
              createExplosion(p.x, p.y, "#ff6600", 25);
              
              // Secret sauce: player loses treats when eaten
              if (secretSauceActive && p.score > 0) {
                const lostTreats = Math.min(p.score, 3);
                p.score -= lostTreats;
                updateScoreUI();
                
                // Spawn lost treats
                for (let i = 0; i < lostTreats; i++) {
                  const t = { 
                    x: doge.x + rnd(-40, 40),
                    y: doge.y + rnd(-40, 40),
                    r: CONFIG.treatRadius, 
                    emoji:'üêü',
                    vx: rnd(-2, 2),
                    vy: rnd(-2, 2)
                  };
                  treats.push(t);
                }
              }
              
              updateStatus(`${p.name} was eaten by Doge!`);
              break;
}
}
}
}

      // Despawn if offscreen long enough or TTL expired
      // Update doge position
      if (!doge.eating) {
        doge.x += doge.vx; doge.y += doge.vy;
      }
      
      doge.ttl -= 16;
      
      // Despawn if TTL expired
if (doge.ttl <= 0 || doge.x < -80 || doge.x > W+80 || doge.y < -80 || doge.y > H+80) doge = null;
}
}
@@ -827,6 +961,9 @@

// Invert controls on touch
for (const p of players){
        // Skip players being eaten
        if (p.beingEaten) continue;
        
if (circleCollide(p.x,p.y,p.r, laser.x,laser.y, laser.r+6)){
// Shield prevents laser distraction
if (!p.hasShield) {
@@ -883,6 +1020,9 @@

// Pull players toward tornado
for (const p of players) {
      // Skip players being eaten
      if (p.beingEaten) continue;
      
const dx = tornado.x - p.x;
const dy = tornado.y - p.y;
const d = Math.hypot(dx, dy);
@@ -944,6 +1084,9 @@

// Check if any player collected this power-up
for (const player of players) {
        // Skip players being eaten
        if (player.beingEaten) continue;
        
if (circleCollide(player.x, player.y, player.r, p.x, p.y, p.r)) {
// Mark as collected
p.collectTime = now;
@@ -1007,62 +1150,37 @@
function updateSecretSauce() {
const now = performance.now();

    // Update countdown timer
    if (!secretSauceActive) {
      const secondsLeft = Math.ceil((nextSecretSauce - now) / 1000);
      if (secretSauceCountdown !== secondsLeft) {
        secretSauceCountdown = secondsLeft;
        updateChaosTimer();
      }
    }
    
// End secret sauce mode
    if (secretSauceActive && now >= nextSecretSauce) {
    if (secretSauceActive && now >= nextSecretSauce + CONFIG.secretSauceDuration) {
secretSauceActive = false;
document.getElementById('warning').style.display = 'none';
updateStatus('');
      
      // Schedule next chaos mode
      nextSecretSauce = now + CONFIG.secretSauceInterval;
}

// Start secret sauce mode
    if (CONFIG.secretSauce && !secretSauceActive && now >= nextSecretSauce) {
    if (!secretSauceActive && now >= nextSecretSauce) {
secretSauceActive = true;
document.getElementById('warning').style.display = 'block';
updateStatus('‚ö†Ô∏è CHAOS MODE ACTIVATED! ‚ö†Ô∏è');
      nextSecretSauce = now + 10000; // Last for 10 seconds
      document.getElementById('timer').textContent = 'CHAOS MODE!';

// Spawn additional chaos
for (let i = 0; i < 3; i++) spawnPowerUp();
if (Math.random() < 0.5) spawnDoge();
for (let i = 0; i < 3; i++) spawnTreat();
}
    
    // Schedule next secret sauce if not active or scheduled
    if (!secretSauceActive && now >= nextSecretSauce) {
      nextSecretSauce = now + CONFIG.secretSauceInterval;
    }
  }
  
  function updateGameTime() {
    if (!CONFIG.timeLimit) return;
    
    const now = performance.now();
    gameTimeLeft = Math.max(0, CONFIG.gameTime - Math.floor((now - gameStartTime) / 1000));
    
    // Update timer display
    document.getElementById('timer').textContent = `Time: ${formatTime(gameTimeLeft)}`;
    
    // End game if time's up
    if (gameTimeLeft <= 0 && !winner) {
      // Find the winner based on highest score
      let maxScore = -1;
      let winningPlayer = null;
      
      for (const p of players) {
        if (p.score > maxScore) {
          maxScore = p.score;
          winningPlayer = p;
        }
      }
      
      if (winningPlayer) {
        endGameWithWinner(winningPlayer);
      } else {
        // In case of a tie, just end the game
        paused = true;
        updateStatus("Time's up! It's a tie!");
      }
    }
}

function loop(t){
@@ -1076,7 +1194,7 @@

// Update UI elements that don't depend on physics tick
updatePowerUpsUI();
    updateGameTime();
    updateCatImagePositions();

while (acc >= dt){
if (!paused && !winner){
@@ -1196,10 +1314,29 @@
ctx.restore();
}

      drawCircle(doge.x,doge.y,doge.r,'#3a2f2b','#5a423a');
      ctx.font = '20px system-ui';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText('üê∂', doge.x, doge.y);
      // Draw doge differently if eating a player
      if (doge.eating) {
        // Larger mouth effect
        drawCircle(doge.x, doge.y, doge.r + 5, '#3a2f2b', '#5a423a');
        
        // Blood effect
        ctx.save();
        ctx.globalAlpha = 0.6;
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.arc(doge.x, doge.y, doge.r - 5, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
        
        ctx.font = '25px system-ui';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText('üê∫', doge.x, doge.y); // Use wolf emoji for eating doge
      } else {
        drawCircle(doge.x, doge.y, doge.r, '#3a2f2b', '#5a423a');
        ctx.font = '20px system-ui';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText('üê∂', doge.x, doge.y);
      }
}

// Lasers
@@ -1241,63 +1378,6 @@
ctx.restore();
}

    // Players
    for (const p of players){
      // Shield effect
      if (p.hasShield) {
        ctx.save();
        ctx.globalAlpha = 0.3;
        drawCircle(p.x, p.y, p.r + 10, '#00ffff', '#00ffff');
        ctx.restore();
      }
      
      // Special effect if player is being meowed
      if (p.isBeingMeowed) {
        ctx.save();
        ctx.globalAlpha = 0.3;
        drawCircle(p.x, p.y, p.r + 8, '#ffffff', null);
        ctx.restore();
      }
      
      drawCircle(p.x, p.y, p.r, p.color, '#ffffff');
      
      // Draw unique cat emoji based on player type
      ctx.font = '28px system-ui';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      
      // Unique cat visuals
      let catEmoji;
      switch (p.name) {
        case 'Grumpy': catEmoji = 'üòæ'; break;
        case 'Nyan': catEmoji = 'üåàüê±'; break;
        case 'Keyboard': catEmoji = 'üéπüê±'; break;
        case 'Bongo': catEmoji = 'ü•Åüê±'; break;
        case 'Shrek': catEmoji = 'üëπüê±'; break;
        default: catEmoji = 'üê±';
      }
      
      ctx.fillText(catEmoji, p.x, p.y);
      
      // Speed boost indicator
      if (p.speedBoost > 1.0) {
        ctx.font = '16px system-ui';
        ctx.fillStyle = '#ffff00';
        ctx.fillText('‚ö°', p.x, p.y - p.r - 8);
      }
      
      // Super Meow indicator
      if (p.superMeow) {
        ctx.font = '16px system-ui';
        ctx.fillStyle = '#ff6600';
        ctx.fillText('üîä', p.x + p.r, p.y);
      }
      
      // Name/emoji label
      ctx.font = '12px system-ui';
      ctx.fillStyle = 'rgba(255,255,255,.85)';
      ctx.fillText(`${p.emoji}`, p.x, p.y - p.r - 14);
    }

// Winner banner
if (winner){
ctx.save();
@@ -1316,6 +1396,17 @@
}

// ======== BOOT ========
  // Preload all cat GIF images
  function preloadCatImages() {
    CAT_GIFS.forEach(url => {
      const img = new Image();
      img.src = url;
    });
  }
  
  // Start preloading images
  preloadCatImages();
  
// Show start screen, wait for Enter/click
// (Game starts via start())
})();
